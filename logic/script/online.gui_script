
local druid = require("druid.druid")

local reg = require("logic.module.reg")
local saver = require("logic.module.saver")

-- hashes
local hash_score = hash("score")
local hash_toast_message = hash("toast_message")

local panel_pos1 = vmath.vector3(-640, 749, 0)
local panel_pos2 = vmath.vector3(360, 749, 0)
local panel_pos3 = vmath.vector3(1360, 749, 0)

local function return_to_menu()
    msg.post("bootstrap:/go", "load_main")
    print("aaaaaaaaaaaaaccccccccc main loading")
end

local function return_to_menu_with_timer()
    timer.delay(6, false, function ()
        return_to_menu()
    end)
end

local function panel_off(panel, callback)
    if reg.check("panel_avaliable") or not panel then return end
    if reg.check("current_panel") ~= panel then return end
    gui.animate(panel, "position", panel_pos3, gui.EASING_INOUTQUAD, 0.3, 0, function()
        reg.set("panel_avaliable", true)
        if callback then callback() end
    end, gui.PLAYBACK_ONCE_FORWARD)
end

local function panel_on(panel, callback)
    if not panel then print("panel_on: panel doesn't exists."); return end
    if not reg.check("panel_avaliable") then
        panel_off(reg.check("current_panel"))
    end
    reg.set("panel_avaliable", false)
    reg.set("current_panel", panel)
    gui.set_position(panel, panel_pos1)
    gui.set_enabled(panel, true)
    gui.animate(panel, "position", panel_pos2, gui.EASING_INOUTQUAD, 0.3, 0, callback or nil, gui.PLAYBACK_ONCE_FORWARD)
end

local function update_score(self, score)
    gui.set_text(self.node_score, score) -- update score text
    msg.post("online_manager", "update_score", {score = score})
end

local function toast_message(self, message, seconds)
    if self.toast_message_showing then return end
    self.toast_message_showing = true
    local pos = gui.get_position(self.node_screen_notification_text)
    local to = vmath.vector3(pos.x + 20, pos.y, pos.z)
    gui.animate(self.node_screen_notification_text, gui.PROP_POSITION, to, gui.EASING_LINEAR, 0.15, 0, nil, gui.PLAYBACK_LOOP_PINGPONG)
    timer.delay(0.4, false, function ()
        gui.cancel_animation(self.node_screen_notification_text, gui.PROP_POSITION)
    end)
    gui.set_text(self.node_screen_notification_text, message)
    timer.delay(seconds, false, function ()
        gui.set_position(self.node_screen_notification_text, pos)
        gui.set_text(self.node_screen_notification_text, "")
        self.toast_message_showing = false
    end)
end

local function add_item_to_mods(self, name, description, code)
    local prefab_nodes = gui.clone_tree(self.node_mods_prefab)
    local root = prefab_nodes["mods_prefab"]
    local text = prefab_nodes["mods_name"]
    local desc = prefab_nodes["mods_description"]
    local button = prefab_nodes["mods_choose_button_panel"]
    local druid_button
    
    if reg.check("amiserver") then
        druid_button = self.druid:new_button(button, function ()
            print("choosen:", name, code)
            reg.set("online_mode_name", name)
            reg.set("online_mode", code)
            reg.set("online_mode_choosen", true)
            msg.post("online_manager", "online_mode_choosen")
        end)
    else
        gui.set_enabled(button, false)
    end
    
    table.insert(self.mods_created_nodes, root)
    table.insert(self.mods_druid_buttons, druid_button)
    --table.insert(self.mods_data, {name = name, ip = ip})
    
    gui.set_text(text, name)
    gui.set_text(desc, description)
    gui.set_enabled(root, true)
    self.mods_grid:add(root)
end

function update(self, dt)
    self.druid:update(dt)
end

function on_input(self, action_id, action)
    if action_id == hash("touch") and action.pressed and action.x then
        if not reg.check("panel_avaliable") and not gui.pick_node(reg.check("current_panel"), action.x, action.y) then
            -- clicked to anywhere except the panel
            --panel_off(reg.check("current_panel"))
        end
    end
    return self.druid:on_input(action_id, action)
end

function on_message(self, message_id, message, sender)
    if message_id == hash_score then
        update_score(self, message.score)
    elseif message_id == hash_toast_message then
        toast_message(self, message.message, message.seconds)
	elseif message_id == hash("positions") then
        local score_pos = gui.get_position(self.node_score)
        local name_pos = gui.get_position(self.node_name)
        score_pos.y = message.pos
        name_pos.y = message.pos
        gui.set_position(self.node_score, score_pos)
        gui.set_position(self.node_name, name_pos)
        score_pos.y = message.rival
        name_pos.y = message.rival
        gui.set_position(self.node_rival_score, score_pos)
        gui.set_position(self.node_rival_name, name_pos)

        gui.set_text(self.node_name, reg.check("username") or "noname")
        gui.set_text(self.node_rival_name, reg.check("rival_name") or "noname")
    elseif message_id == hash("rival_score") then
        gui.set_text(self.node_rival_score, message.score)
    elseif message_id == hash("connection_lost") then
        reg.set("online_gameover", true)
        panel_on(self.node_connection_lost_panel)
        return_to_menu_with_timer()
    elseif message_id == hash("we_won") then
        reg.set("online_gameover", true)
        panel_on(self.node_won_panel)
        return_to_menu_with_timer()
    elseif message_id == hash("we_lost") then
        reg.set("online_gameover", true)
        panel_on(self.node_lost_panel)
        return_to_menu_with_timer()
	end
    self.druid:on_message(message_id, message, sender)
end

function final(self)
    self.druid:final()
end

function init(self)
    msg.post(".", "acquire_input_focus")

    -- genius node define method
    self.template_nodes = {
        "screen_notification_text",
        "score",
        "rival_score",
        "name",
        "rival_name",
        "connection_lost_panel",
        "lost_panel",
        "won_panel",
        "mods_panel",
        "online_mode_text",
        
    }
    for _, value in ipairs(self.template_nodes) do
        self["node_" .. value] = gui.get_node(value)
    end

    reg.set("panel_avaliable", true)
    reg.set("gameover_panel_avaliable", true)

    self.druid = druid.new(self)

    -- druid buttons

    self.connection_lost_ok_button = self.druid:new_button("connection_lost_ok", function ()
        return_to_menu()
    end)

    self.lost_reject_button = self.druid:new_button("lost_reject", function ()
        return_to_menu()
    end)

    self.won_reject_button = self.druid:new_button("won_reject", function ()
        return_to_menu()
    end)

    -- mods grid with druid --start

    self.node_mods_prefab = gui.get_node("mods_prefab")
    -- set prefab disabled
    gui.set_enabled(self.node_mods_prefab, false)

    self.mods_created_nodes = {}

    self.mods_grid = self.druid:new_grid("mods_content", "mods_prefab", 1)
    gui.set_size_mode(gui.get_node("mods_content"), gui.SIZE_MODE_MANUAL)
    self.mods_scroll = self.druid:new_scroll("mods_view", "mods_content")
    self.mods_scroll:bind_grid(self.mods_grid)

    self.mods_data = {}
    self.mods_druid_buttons = {}

    local online_modes = {
        suicide = {name = "Suicide", description = "The player who knocks the ball down wins."},
        point1000 = {name = "1000 point", description = "The player who reaches 1000 points wins."},
        point2000 = {name = "2000 point", description = "The player who reaches 2000 points wins."},
        point3000 = {name = "3000 point", description = "The player who reaches 3000 points wins."},
        ball_8 = {name = "Blue ball", description = "Whoever gets the blue ball wins."},
        ball_9 = {name = "Red ball", description = "Whoever gets the red ball wins."},
        ball_10 = {name = "Brown ball", description = "Whoever gets the brown ball wins."},
    }

    reg.set("online_modes", online_modes)

    if not reg.check("online_mode_choosen") then
        for key, value in pairs(online_modes) do
            add_item_to_mods(self, value.name, value.description, key)
        end
        panel_on(self.node_mods_panel)
    else

        -- timer
        saver.save("online_timer", (saver.load().online_timer or 0) + 1)

        local online_modes_timer = saver.load().online_modes_timer or {}
        online_modes_timer[reg.check("online_mode")] = (online_modes_timer[reg.check("online_mode")] or 0) + 1
        saver.save("online_modes_timer", online_modes_timer)

        local rival_names_timer = saver.load().rival_names_timer or {}
        rival_names_timer[reg.check("rival_name")] = (rival_names_timer[reg.check("rival_name")] or 0) + 1
        saver.save("rival_names_timer", rival_names_timer)
        -- timer

        gui.set_text(self.node_online_mode_text, "Mod: '" .. reg.check("online_mode_name") .. "'")

    end
end
