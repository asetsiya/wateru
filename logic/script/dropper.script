---@diagnostic disable: undefined-field
local reg = require("logic.module.reg")
local balls = require("logic.module.balls")
local saver = require("logic.module.saver")
local camera = require("orthographic.camera")

-- hashes
local hash_touch = hash("touch")
local hash_sprite_size = hash("sprite_size")
local hash_gameover = hash("gameover")
local hash_replay = hash("replay")

local next_balls = {}

-- for development use only
-- must be nil for real game
local dev_ball = nil

local function set_randomseed()
    local ifaddrs = sys.get_ifaddrs() or {}
    local sysinfo = sys.get_sys_info() or {}
    local iface_data = ""
    for _, iface in pairs(ifaddrs) do
        iface_data = iface_data .. tostring(iface.address or "")
        iface_data = iface_data .. tostring(iface.mac or "")
        iface_data = iface_data .. tostring(iface.name or "")
    end
    local sys_data = ""
    for k, v in pairs(sysinfo) do
        sys_data = sys_data .. tostring(v)
    end
    local time_data = tostring(socket.gettime())
    local raw = iface_data .. sys_data .. time_data
    local hash = MD5.calculate(raw)
    local num = 0
    for i = 1, #hash do
        num = (num * 31 + string.byte(hash, i)) % 2147483647
    end
    math.randomseed(num)
    print("Random seed:", num)
    for i = 1, 10 + math.random(1, 20) do
        math.random()
    end
end

local function set_second_ball()
	go.animate("second_ball_place#ball", "scale", go.PLAYBACK_ONCE_FORWARD, 0, go.EASING_OUTBACK, 0.2, 0, function()
		sprite.play_flipbook("second_ball_place#ball", "ball_" .. next_balls[2])
		go.animate("second_ball_place#ball", "scale", go.PLAYBACK_ONCE_FORWARD, 1, go.EASING_OUTBACK, 0.3, 0)
		table.remove(next_balls, 1)
		table.insert(next_balls, dev_ball or math.random(1, 5))
	end)
end

local function set_ball(self)
	if self.cooldown then return end      -- if in cooldown, skip.
	if reg.check("gameover") then return end -- if in gameover, skip.
	self.cooldown = true
	timer.delay(0.3, false, function()
		if not self.is_nextball_complette then
			next_balls[1] = dev_ball or math.random(1, 5)
			next_balls[2] = dev_ball or math.random(1, 5)
			self.is_nextball_complette = true
		end
		self.current_ball = next_balls[1]
		set_second_ball()

		--self.current_ball = 8
		if reg.check("gameover") then return end -- if in gameover, skip.
		self.ball = factory.create("/ball_factories#ball_" .. self.current_ball, go.get_position(), nil,
			{ is_dynamic = false }, vmath.vector3(0.5, 0.5, 0.5))
		msg.post(self.ball, "set_parent", { parent_id = self.id, keep_world_transform = 1 })
		if self.pressed == true and reg.check("panel_avaliable") then
			msg.post("#sprite", "enable")
		end
		go.animate(self.ball, "scale", go.PLAYBACK_ONCE_FORWARD, 1, go.EASING_OUTBACK, 0.3, 0, function()
			self.cooldown = false
		end)
	end)
end

local function update_score(self)
	local score = (2 ^ (self.current_ball - 1)) + (saver.load().score or 0)
	reg.set("score", score)
	msg.post("/gui", "score", { score = score })
end

local function drop(self)
	if self.cooldown then return end                 -- if in cooldown, skip.
	if reg.check("gameover") then return end         -- if in gameover, skip.
	if not reg.check("panel_avaliable") then return end -- if in any panel, skip.
	msg.post(self.ball, "set_parent", { keep_world_transform = 1 })
	msg.post(self.ball, "fall")
	sound.play("/sounds#pap")
	balls.add_ball(self.ball)
	update_score(self)
	set_ball(self)
	reg.set("gameover_panel_avaliable", true)
end

local function game_over(self)
	if go.exists(self.ball) then go.delete(self.ball) end
end

local function replay(self)
	self.cooldown = false
	--go.delete(balls.get(), true)
	for index, value in ipairs(balls.get()) do
		if go.exists(value) then
			go.delete(value)
		else
			print(index)
		end
	end
	balls.reset()
	reg.set("gameover", false)
	set_ball(self)
end

local function screen2world(action)
	if not action.x then return action end -- if no mouse input, skip.
    local screen_pos = vmath.vector3(action.x, action.y, 0)
    local world_pos = camera.screen_to_world(nil, screen_pos)
    local new_action = action
    new_action.x = world_pos.x
	new_action.y = world_pos.y
	return new_action
end

function on_input(self, action_id, action)
	if not reg.check("dropper_active") then return end -- if the dropper isn't active, skip.
    action = screen2world(action) -- screen_position to world_position
	if action_id == hash_touch then
		if action.pressed == true then
			self.pressed = true
			if self.cooldown == false and reg.check("gameover") == false and reg.check("panel_avaliable") then
				msg.post("#sprite", "enable")
			end
		elseif action.released == true then
			self.pressed = false
			msg.post("#sprite", "disable")
			drop(self)
		end
	elseif action.x and action.y then
		if not reg.check("panel_avaliable") then return end -- if in any panel, skip.
		if self.cooldown == false and self.pressed == true and reg.check("gameover") == false then
			msg.post("#sprite", "enable")
		end
		local pos = go.get_position()
		---@diagnostic disable-next-line: param-type-mismatch
		pos = vmath.vector3(vmath.clamp(action.x, self.clamp1, self.clamp2), pos.y, pos.z)
		go.set_position(pos)
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash_sprite_size then
		self.clamp1 = 13 + (message.sprite_size / 2)
		self.clamp2 = 704 - (message.sprite_size / 2)
	elseif message_id == hash_gameover then
		if go.exists(self.ball) then
			game_over(self)
		end
	elseif message_id == hash_replay then
		-- if gameover, replay. game is not over? first gameover, then replay.
		if reg.check("gameover") then
			replay(self)
		else
			game_over(self)
			replay(self)
		end
	end
end

function init(self)
	msg.post(".", "acquire_input_focus")
	msg.post("#sprite", "disable")

	self.clamp1 = 0
	self.clamp2 = 720
	self.ball_scale = 0
	self.current_ball = 1
	self.cooldown = false
	self.id = go.get_id()
	self.pressed = false
	self.is_nextball_complette = false

	set_randomseed()
	set_ball(self)

	sound.play("/sounds#music")
end
